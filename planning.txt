31st of August, 2023

We're redoing the old bresenham line movement system we did a while ago. But this time we're doing it cleaner.

Last time I used this overly complicated linear line equation system, but in reality we can just use sine and cosine and a vector to derive our ending x position. Or so I thought. We've run into some sort of bug where, now that I've rigged this up to an analog stick with variable degrees, our movement gets stuck and stops at certain points. Since our logic resets the movement and starting point of the SmoothMove instance whenever the angle or vector changes, my first thought is that the frequent angle changes that occur when using an analog stick trigger frequent resets. So the object feels "stuck" when changing directions. 

However, I also noticed that the moving up and to the left stays very fast. Moving down and to the right is the worst. I think it's very likely there is a floor() somewhere in our code that favors movement to the left and up. Let's look around for that first.

We were able to resolve the inconsistency of the sticking (we were rounding our final result, instead of the adjustments). But now the object just feels like it's consistently sticking. I'm confident that our issue is abandoning any progress along the x/y axis made when changing the angle. My first thought to fix this is, strangely enough, going back to something similar we had in the old system. In that system we kept track of the distance travelled along the x/y axis. And those values only reset once there was no change, or the direction flipped.

I think we should try this. However I'm relaizing this means we'll be constantly inferring the x/y magnitude of the stored vector. At this point I think it makes more sense to have SmoothMove store an x/y magnitude instead of an angle and magnitude. But create functions that use a vector to set the x/y magnitude.

Wait, I might be being an idiot. Can we just keep track of the distance traveled by x/y magnitudes relative to a start X, round those distances traveled towards 0 when calculating the x/y position, and simply reset the distance traveled to 0 and the starting position when the sign of the magnitude changes?

That did not work. I believe that's because anything short of an equation deriving one y per x, or the reverse, allows for more than one y per x. And that's what creates the waggle we're trying so hard to get rid of.


1st of September, 2023

We were able to fix the sticking issue. When the x/y magnitudes changed, we simply set the x/y to the currently calculated positions, but also removed the integer portion of the distance_x/y value. For example, on magnitude change:

start_x: 0;
distance_x: 7.4

would become

start_x: 7;
distance_x: 0.4;


We also reset the distance_x/y to 0 on sign change of magnitudes. We've run into another bug now after some more rigorous testing. We're keeping track of distance travelled for both x and y. However since we infer either x or y from a line equation based off the slope, at any given time one of the sitance values is pointless to track. It's also "wrong" compared to the line equation. 

For example, imagine we started at 0,0 and moved 5 times with the vector (-0.7, 0.3). From simple math we could conclude our end position would be (-3.5, 1.5). And the internal state of our SmoothMove would reflect this:

start_x: 0
start_y: 0
distance_x: -3.5
distance_y: 1.5

Remember that we infer y from x with this slope of 0.3/-0.7. And in this case our exact y turns out to be 1.5, the same as the y infered from distance. Now let's change the vectors we're travelling with to (-0.02, 0.1). When we first change this our SmoothMove state will reset the distance x/y and the start x/y and our internal state will become:

start_x: -3
start_y: 1
distance_x: -0.5
distance_y: 0.5

Now let's travel with this vector 5 times. Our state becomes.

start_x: -3
start_y: 1
distance_x: -0.6
distance_y: 1

Notice that the distance travelled is maintained for both axis. Now in this scenario our rise is greater than our run, so we infer our x from our y, which with this slope of -0.2 yeilds an x of -3.4. You'll notice that this is not quite the same as our above distance_x + start_x of -3.6. Luckily since we round to integers towards 0 for changes, our final x is the same with either. But now let's change the vector to (-0.1, -0.3):

start_x: -3
start_y: 2
distance_x: -0.6
distance_y: 0

And let's travel 4 times:

start_x: -3
start_y: 2
distance_x: -1
distance_y: -1.2

Since our rise travels further than our run, we infer our x from our y. So with a slope of 0.333 we can infer our true x from 0.333 * -1.2 + -3, which gives us -3.3996. This is quite different from the x we could infer from just adding start_x and distance_x, which gives us -4. And most importantly, since our logic rounds changees towards 0 when inferring x/y so we return integers, our change value of 0.333 * 01.2 is -0.3996 which rounds to 0. So the final value is -3. That's definitely not -4.  

So what's the problem? The problem here is that keeping track of the distance x/y separately yields an untrue change in vectors when the slope changes from being y/x to x/y. In the above state we infer x from y by calculating a new "distance_x" from a line equation, and in this case that change is 0.333 * -1.2, which is -0.3996. But our internal distance_x is -1. So if we changed vectors to a flipped slope our internal state would change to:

start_x: -4
start_y: 1
distance_x: 0
distance_y: -0.2

And this is wrong! It should be:

start_x: -3
start_y: 1
distance_x: -0.4 // -0.3996 rounded
distance_y: -0.2

But also note that if we flipped to a slope with a greater run than rise, we'd be inferring our y from our x, and so the true "distance_y" wouldn't be -0.2. It would be whatever change we got from our slope * -0.4, or whatever the x distance would be after travelling.

So, now that we've explained the bug, how can we solve it? I actually think the solution isn't too tricky. We already explained how we can infer the true distance x/y from the current slope. I think that we get ride of distance_x/y in favor of just a single distance variable. And use the slope to infer if this distance is along the x or y axis when determing final x/y values. Whenever the vector changes, if the slope has flipped from greater run to greater rise, or the reverse, we calculate the new distance using the old slope and old distance. As an example, let's reimagine the movements from above but using this new system. 

start: (0,0)
vector (-0.7, 0.3) 5 times
vector (-0.02, 0.1) 5 times
vector (-0.1, -0.3) 4 times

Our new starting state would be (and lets include the vector for clarity this time):

magnitude_x: 0
magnitude_y: 0
start_x: 0
start_y: 0
distance: 0
// inferred true position:		(0, 0)
// changes towards 0 position:	(0, 0)

Now we'll set the vector to (-0.7, 0.3) and travel 5 times. Note that this has a greater x travel distance than y, so we infer y from x. Our state is now:

magnitude_x: -0.7
magnitude_y: 0.3
start_x: 0
start_y: 0
distance: -3.5
// inferred true position:		(-3.5,	1.5)
// changes towards 0 position:	(-3,	1)

Change vector to (-0.02, 0.1). Notice that this has a greater run than rise, so our distance will be changed to the difference between the rounded towards 0 interger y and the true inferred y. But to do this we can simply reset the starting and distance values, then multiply distance by the old slope:

// done with actual values calculation
true_y =			-3.5*(0.3/-0.7)+0 = 1.5
towards_zero_y = round_towards_zero(-3.5*(0.3/-0.7))+0 = 1
new_distance = 1 - 1.5 = -0.5;

// done with new distance and old slope calculated
magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: -0.5

distance * slope = -0.5*(0.3/-0.7) = 0.1


By coincidence this would be the same as our distance before. But regardless we have our new state:

magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: 0.5
// inferred true position:		(-3.1,	1.5)
// changes towards 0 position:	(-3,	1)

Notice that the true x position changed from before. Although not ideal, I prefer this to our less organized system from before. At least this is consistent. Now we travel 5 times:

magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: 1
// inferred true position:		(-3.2,	2)
// changes towards 0 position:	(-3,	2)

Change vector to (-0.1, -0.3)

magnitude_x: -0.1
magnitude_y: -0.3
start_x: -3
start_y: 2
distance: 0
// inferred true position:		(-3,	2)
// changes towards 0 position:	(-3,	2)

Now travel 4 times:

magnitude_x: -0.1
magnitude_y: -0.3
start_x: -3
start_y: 2
distance: -1.2
// inferred true position:		(-3.4,	0.8)
// changes towards 0 position:	(-3,	1)



Ok, I've been trying to implement the changes I described above. But I am running into all kinds of issues with capturing the true distance after changing slope type. I've decided that, although perhaps less mathematically elegant, our old system was much simpler and worked just fine. To reiterate, what we used to do was keep track of the distance travelled for both x and y. However when the user requested the position of x/y we would infer one of them based off the slope of the vector. This meant one of those values was basically useless until the slope changed. And when the slope did change we'd reset the starting and distance x/y. What this ultimately means is that when the slope does change, our new axis value will switch from being inferred to being what it would have been had we not been inferring it. Contrary to what I said above. I think this is fine. We end up throwing out the distance of the x/y we were travelling on when we switch slopes anyway, so we end up with imperfection one way or another. This way is just much easier to code and read.


It's clear I've made some sort of serious error in my logic. I rigged up something that let's me move a square around with the raw analog stick. It has the jutter/waggle issue that SmoothMove is supposed to fix. But other than that the movement is way smoother. To test further I rigged it to move in a circle by telling it to move by vector, but increasing the angle slightly each frame. It does not move in a circle like we'd expect. Instead it moves in a square shape. Something is very wrong.

I believe I have uncovered the secret of why our system doesn't feel smooth, and feels clunky. After carefully watching our circle drawing rig, it's clear that since the x distance resets when the angle changes, the y never actually changes until the slope is so aggressive that it forces a change of y with even the smallest x distance. After about maybe 2 dozen iterations this is the state I'm looking at right now:

start_y: 70			// program started at 70
start_x: 156 		// program started at 150
magnitude_x: 0.19
magnitude_y: -0.063
distance_x: 0.487
distance_y: -1.048

Remember that our distance_y is updated even though it's not what we use to calculate the final y. But notice that it's beyond -1! If we weren't using our inference system the y would've changed by now. But the y we infer is the slope times distance_x, which turns out to be -0.16. Not enough to trigger a change. And what's worse, when the angle changes again we go through our reset logic which removes the integer portion of distance_y. This is why the movement has still felt stuck and favoring right angles.

We need to think through how we're going to fix this. I'm confident that we need to adjust the start_y by distance_y when the abs(distance_y) is greater than 1. I tried simply adding the integer value of distance_y to start_y when an angle changes. But this does not work because if the vector stayed the same long enough, then the start_y and distance y were updated correctly.

Perhaps we should try only changing the start_y by the integer of the distance_y if the inferred y on vector change is the same as start_y. This may work because it accounts for situations where the y would've changed had the vector not been changing, but ignores situations where it has changed already. So it's like a "catch" for missed y changes.

(note the above also refers to x changes when we're inferring x from y)

Our small fix certainly helps a lot, but we're not quite there. There are now small skips in the line sometimes. And our circle algorithm doesn't draw a perfect circle, and I'm sure it should. 

We've improved it. But it's clear we don't fully understand what's happening under the hood, or what should be happeneing. From observation and expermientation. We found out that gaps were likely happening when slope type did not change. By only accounting for the missed x/y changes when slope stays the same, we were able to get rid of some gaps. But I still see gaps happen sometimes. And after digging some more, it's clear that sometimes the gaps appear because of our new fix! I'm tempted to try one more thing for today and then give up. Let's see if we can "store" a change. We'll mark that a distance_x/y integer change should have happened using our current logic. But then when we actually update distances, if the distance update accounts for our stored change, we won't make it. 

The fix didn't work. My brain is fried. We'll have to look at this some other time.


3rd of September, 2023

Coming back to this with a fresher head. Still don't really understand what's going on underneath the hood, but I have some thoughts I should get down.

Firstly, something that became clear to me is that using the same distance_x when the the vector changes slightly is wrong. Imagine we have a slope of 1, and we've travelled 0.8 along the x axis. Well if we use basic vector math, travelling 0.8 along the x axis with a slope of 1 is the same as travelling 1.13 along that vector. Now imagine if that was our state:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 1
distance_x: 0.8
distance_y: 0.8

With our current "round distance changes towards 0" logic, this results in a position of (0, 0). But what if we changed the slope from 1 to 0? Suddenly our state would be:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 0
distance_x: 0.8
distance_y: 0.8

This would yield the same position of (0, 0), but that's not correct! It should be:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 0
distance_x: 0.131
distance_y: 

Which would yield a position of (1, 0). I believe we should hold a rule in our logic that changing vectors maintains the distance travelled along the vector. This does break physics but let's go with it for now and see what we come up with first. The only time we'll clear distance travelled is when the magnitude of the new vector is 0.

In fact I'm very tempted to go back to our old system of maintaining the actual magnitude and angle of the vector in our state instead of the x/y magnitudes. Actually I'm not even sure we need to keep track of "magnitude". We could just keep track of distance travelled at that angle since we can reset our start_x/y positions once both have crossed the integer threshold. Our new state could literally be:

start_x
start_y
angle
distance

We could infer slope from the angle, and use the logic we have now for determining if we're inferring y from x or x from y. Let's try this.

Oh wow. We ran into the same problem we ran into before over the weekend. This problem is difficult for me to hold entirely in my mind. When the angle changes frequently, every frame for example, if we don't keep track of the distance we would've covered over the off axis, then the only time we can actually switch to the off axis is when the slop of the ange is so aggressive which switch from inferring y from x to the other way around. This is why we kept track of distance for both x and y. 

Let's start calling distance delta.

What I'm wondering now is if there's a way to keep track of the off axis, basically the same way we did with distance_x/y, but this time ensure we're not losing data when the angle changes.

Let's first try making a value to track changes to the off axis as they happen. I have a theory that we could write cod that, once a large enough change in the off axis is detected, we make that change to the off axis regardless of the line equation, and setback the on axis enough to account for this change.

A logic point that I'm having trouble understanding is if this change along the off axis could ever be greater than 1 (or -1). Perhaps after adding to delta we need to see if a change has happened and remove it from our off axis tracking if it has? These are the kinds of uncertainties that make me hesitant to code further. Diving into the problem without a strong understanding of what's going on is just going to breed bugs.

Oh wait. I just had the dumbest idea in the world. What if we allowed SmoothMove to keep track of non-integer start_x/y positions? And we simply calculate the resultant x/y from our vector as we've been doing? We'd only reset the start_x/y to their integer values when tried to advance with a magnitude of 0. Let's see where this gets us first.

This new strat may have been the correct choice all along. However there are still some weird bugs. It's 5:00am and I should've gone to bed so many hours ago. Tomorrow (later today) we'll solve this.


September 4th, 2023

Ok I slept like crap, but our brain is at least slightly fresher. We uncovered the issue from last night. We weren't capping our angle between 0 and 2pi, so our angle was actually greater than 2pi at certain points. Since our logic doesn't account for that, we were using the wrong slope calculation and dividing by 0.

This new system is looking promising, but there's still a few things to work out. Next we need to be sure that it will never create stair steps. Next let's try and force stair steps, and then uncover what's causing them.

So basically we weren't actually inferring x or y from the other, and only using integer values. We were just display a real rounded somehow, which is no different from just tracking the x/y and displaying it rounded. We have another bug, this time when travelling at certain diagonals the final x/y position after travelling with a magnitude of 0 changes from what it should be. It looks like this is because we change the start_x/y on angle change (which also happens when we set vel to 0). But since we need the old start_x/y to generate the correct integer x/y position, we can't. The data has changed once we change start_x/y to the new one. Instead let's try only updating the start_x/y when changing delta with a different angle. We'll have to track the previous angle for this to work.

Nope. Our fix did not work. I'm still confused and I'm ready to give up on this project.

We uncovered that we weren't carefully checking if we were actually using a velocity of 1 at all times. We're going to undo some code, and make sure we're testing more carefully. let's reset everyting to the way it was before we tried using reals for start_x/y.

I have this crazy idea that we could use the same inference logic, but only ever add to the delta and angle when changing angles. It's only once we move by a magnitude of 0 that we reset start_x/y. Quick correction, we'd have to calculate the angle and delta that results from teh previous vector and the new vector.

My theory is that our current line derivation logic when the angle stays the same for a long delta works. But if we instead created a new vector based off changes in angle by summing the new and old, we'd constantly have a correct reference to where the point should be. We'd still round towards start_x/y, which would create an imperfect drawing. But if we reset whenever the magnitude of the new vector is 0, it should be good enough for our simple games. 

I think we've basically reset everything. There is a bug with my arcade stick where the diagonals aren't perfect for some reason but I'm going to ignore this for now since it works with keyboard. So I'm assuming the math is correct but there's some quirk with the stick I don't know about.

Trying to draw the point as a sum of vectors did not work. Well, technically it "works" but it doesn't have the clean pixel perfection that we're looking for. So we're sort of back at square one. I'm tempted to try the off-axis accumulation tactic again.

Turns out our arcade stick issues was the stick itself. It wasn't returning a perfect angle. We fixed it by using some rounding to snap to cardinal directions.

To simplify our job, I think we can safely assume a reset when the angle change is equal to or greater than pi/4. When it comes to accounting for missed changes, I think we can also say that if we experienced a change on the current angle, we don't have to account for missed changes. In my mind I can't conceive how to handle switching from deriving y from x to x from y. If y is the off axis and we're slowly accumulating missed y changes, perhaps from slowly turning a control stick to dead left towards up, I understand that at some point our accumulated y would be greater than 1 (or -1) and we'd have to adjust our values so our line represents this (probably by changing the start_x/y?). But let's say we're moving at slightly less that pi/4. In the same way that moving at an angle slightly greater than 0 will slowly accumulate change towards a positive y change, this slightly less than pi/4 should accumulate towards a negative y change. and further more what happens when the angle changes accross the deriving y from x threshold? I don't understand if that should somehow transfer the accumulated off axis to the new off axis, or just ignored, or some sort of offset with start_x/y should happen right there? 

I have another idea that might be better. Before we tried doing this crazy thing where we added vectors together after each change to try and infer the final drawn point from all vector additions. It didn't work, but what if we tracked something like that between resets? And if the distance between our vector accumulation and our calculated point (which could still use our same logic) was too great, we'd reset to the vector accumulated point. Let's try that and see what happens.

A quick note. This is clearly not good programming. We should instead form a solid plan that we know will work, then implement it. But I'm frustrated and I want to just throw my head against this thing.

The error correction ideas is close. Very close. When using the analog stick it has loads of gaps and mistakes in it, but the movement is otherwise the correct speed and follows the correct lines. That's if we use sqrt(2) as our error correction distance. If we use 1 as our error check, no gaps appears in our lines, but the stick still favors cardinals and intermediates, and "sticks".

Small revelation. We were resetting our error correction when the error was high enough. Except this didn't accomplish anything because we'd lost data on the axis that didn't change. Which was the whole point of this. We changed it so that we only reset the error of the axis that has changed. This looks "better" but it's still wrong. I have a new idea. Perhaps we should always change the calculated values to the error if they're too far off. However we'll only reset the error_correction data if we reset both axis.

Well I'll be. That's the greatest success we've ever had with this. And it makes sense why it works. We're always keeping track of what the "true" value should be. And any time the calculated values are too far off we set them to the error corrected values. So it's always "correct". And we only reset this error correction value if we end up resetting both axis. The problem I see now is that the circle test slowly moves. Is this something that can be resolved? Or is this an inevitable evil with something like this?

We've found a unique situation where our error correction is off from a consistent line. It looks like this is because the magnitudes of the line are less than an integer and our error correction system really only prevents stair stepping for velocities 1 or greater. I tried a couple things to fix this but nothing worked. What I think I'll have to do is only trigger error correction if the equation of the error line is different from the equation line of the SmoothMove. We should also trigger error correction if the angle changed just in case we end up with the same equation by coincidence, but arrived from radically different vectors.

Welp, that's closer still but not quite right. There are still small skips when controlling the pixel with a controller. I've also noticed it favors cardinal directions more heavily than I was expecting.

After fixing an error in our tests. Most of the gaps appear to be gone! It looks like I had made a logic mistake in when we should do error correction. I could've sworn I still saw some gaps, but I'm not sure how to test this precisely. Maybe the next best step is to make a test for this.

We tried making a fix for the gaps by making setting the smooth move position to a pixel in between its calculated position and error position when the error was larger than sqrt(2) (adjacent diagonal pixels). By some miracle this appears to have worked really well. We also made a pretty thorough test for checking gaps. it randomly moves a smooth move instance thousands of times, and checks the distance between each movement to ensure it's never greater that sqrt(2). I am VERY cautiously optimistic right now. It's performing the movement I expected. There are two major things still on my mind:

1. I think I can improve the pixel gap fix further. Instead of just setting it to a pixel in between, we could set it to a pixel, then tastefully adjust the error correction so that it's closer is a way that doesn't cause stair stepping. Some stair steps are probably inevitable, but we may be able to get way closer to 0 than I thought.

2. There's still nothing in here for collision checking. I still have to think through how I'm going to handle that. I know I want the user to pass a callback function to the smooth move that determines if a position is "colliding". The callback would pass in the possible position of the smooth move given a vector movement. It's possible this won't be that hard. We're finally uncovered the logic to determine the "correct" next position. So all we need to do is try positions from where the smooth move is to the correct next position, inching it 1 pixel at a time, until we either reach the correct position or the callback returns true for "colliding". We could also do slides by incrementing just the x or y magnitude, and checking the callback for each individually.

3. It still seems to favor diagonals, and I have no idea why. Worth investigating, understanding, and hopefully fixing.

I was thinking of exploring fixing stair stepping, but I'm not longer convinced it's a problem with error correction. I'm starting to think it's only happening when changing directions to a 90 degree angle quickly enough that stairstepping is actually the most mathematically correct representation. I think I'll stop worry about stair stepping for now, and focus on collision detection instead. I also wonder if the circles appearing to favor diagonals and straights is actually just what circles look like at low res. These are all things I should make sure I understand, but right now the package is working well enough to use. And I think setting up for collisions is the next most important thing.

Just added some code for collision checking. It's not quite right but seems to be close. Today was a big success. Maybe tomorrow we can really finish this thing.


5th of September, 2023

We were able to fix the bug with our collision sliding fairly easily as well as catch a missed infinite loop bug. Next step is to write more and complete tests for collisions.

Wait a second. I just realized we shouldn't put collisions in at all. Collisions are so game specific, our collision system might not work for the user. What we should actually do is add a "position if moved by vector" function. Since most logic for collisions I've seen online work by checking if there would be a collision at a spot, and only moving if there's not, we need to allow for the user to know where a SmoothMove would end up if a vector was applied. Same for moving by magnitudes.

So, a bit dramatic, but let's rip out all this collision code we put in. And instead put in those "potential position" functions.

Ripping out all the collision code turned out to not be difficult at all. And we were able to fairly easily make our own collision code using new "position if moved by vector" functions. After hammering out a few more bugs and adding some tests. I'm genuinely at a loss for what's left in this project besides tidying comments, documentation, and releasing.

After doing some tidying, and more observing, there are definitely still nasty stairsteps in this thing. It might be worth releasing it as is just to have something out there. It does work perfectly fine with just the cardinals and intermediates. Ah, we were able to identify an error with perfect diagonal movement. when moveing at magnitudes 0.5 and 0.5, the smooth move should perfectly alternate between moving and not. Sometimes it doesn't move when it should.

Got some insight into what's causing the stair stepping. Firstly, we're definitely experiencing stair stepping on straight lines. And it looks like it's because our logic doesn't correctly switch our state to our error data if they're close enough. Let's note that in this stairstep case the vector is unchanging, but the error correction constantly things the result of the line equation is wrong. But given what this project is, if we have consistent movement along a line, then that line is correct, not the error. I wonder if we can setup some simple rules during error correction:

If the angle changed, we fit the line equation to the error.
If the angle did not change, we fit the error to the line equation.

We've made a new error correction system that passes our basic stair step test. And also appears to be "correct" but still doesn't feel right. And from my study here's why: When there is an error, we changed the error to correct towards the line if the angle had not changed. This fixes stair stepping, but introduces the same problem we've seen before of resetting the accumulated error to 0. If we move a few frames at an angle close to zero, then increase it slightly and move a few more frames, increase slightly again and move a few more, each time we change the angle the calculated position and error position will be the same, but we erase whatever accumulated, unaccounted for error there was. So we need to not "set" the error to the line, but adjust it by the difference.

Man I just thought. Maybe I'm waaaay over complicated this by having a vector for error correction. What if we just kept track of a simple real x/y position, modified by the exact x/y magnitudes of all changes. We could be lazy and just floor it to get the integer value. And whenever the error between this error and our calculated position is too great, we simply adjust our line towards this error? Let's make a new branch and try that.

This seems to be much better now. The movement feels super smooth and correct. And it's passing all my tests except for stair step. All we do here is keep track of the real x/y position, and round it towards our start_x/y when checking for errors. And if there is an error, we adjust the start_x/y by the difference.

I'm having trouble understanding the exact math behind why the stair step still happens. What I believe is happening is that given certain parameters, even though the angle may never be changing, the plot of the error line and calculated line are always 1 off. So adjusting sthart_x/y by 1 doesn't accomplish anything because it just sets it to "off" from the other side instead. My current thought is that after moving the calculated value closer to the error, we could move the error closer to the fixed value as well. 

In our example where we move by (0.2, 0), and then continually by (0.2, 0.2). The calculated line will never be aware of that initial 0.2 change. But the error is always aware of it, so there will always be instances where the line jumps to get closer to the error. But since they're parallel lines, they will never match. I'm starting to feel confident that we need to adjust the error closer to the new start_x/y. My gut tells me we should move error to half way between the fixed value and its current value. 

Actually wait. We want the error to be a sort of guide post. It's only when travelling along the same line for a while that we want it to stop being a guide post. Maybe we should keep track of how many movements along the same angle we've made to determine if we should move the error to the calculated value. Actually, delta already does that for us in a way. There's got to be an equation to determine how much we should adjust the error to the line.

Not really having luck. It's possible we need to move the error closer to the "real" value of x/y. 

Small aside. Just realized that you can disable feather for an entire file. I should definitely do this on my packages so my particular coding styles don't throw errors for anyone who uses it.

After some observing, I'm very confident about adjusting the error towards the real calculated position. I've just witnessed a situation where the real calculated position is further away from start_x/y than the error_x/y is. 

I was wrong. Adjusting the error towards the real position doesn't fix stair stepping at all. And it breaks gaps. I'm frustrated because this means my mental model of this code is wrong. That should have fixed it. And there is certainly no reason that moving the error closer to the real would ever break gap fixing. I mean it obviously did, I just can't understand why.

A thought I was just having was: What if it makes sense to adjust the delta closer to the error on correction? Consider this state:

start_x:	0
start_y:	0
angle:		7*pi/4
delta:		1
error_x:	1.1
error_y:	1.1

In this scenario, our real position is (0.71, 0.71) our calculated position is 0,0. Since error rounded to start yields 1,1 we have to make a correction to both start_x and start_y. But after adding 1 to start_x/y our real position is (1.71, 1.71). That's actually futher away from our error of 1.1 than before! I have a strong suspicion that we should alter the delta so the result of our vector is as close to error as possible. 

My brain might be totally fried on this project. I was just thinking to myself: Why can't I just reset the SmoothMove state to the error_x/y when the error is greater than 1? Welp I tried doing just that and it works just as well as whatever I had before:

if (_error >= 1) {
	start_x = _error_x;
	start_y = _error_y;
	delta = 0;
}

That's it. I have to wonder if now that I've changed this to something much simpler, my previous idea of moving the error closer to the calculated vector_x/y value as delta increases actually makes sense now. Let's try it.

Still puzzling through it, but it occured to me we may want to make this change to error position before we error correct. If the smooth move suddenly moves by a massive magnitude at a slightly different delta, we're going to want to ignore the old error position at that point and let the line calculation take lead.

We are much closer. Our error correction actually passes the gap test. It's still struggling on the stair stepper test though, and I'm not sure why. I'm currently staring at a situation where we're moving along a vector at an angle of 0.259 radians. We're correcting the error at 100%, and somehow our line equation still generates generates a stair step? The math beyond that shouldn't be possible.

I know why it's causing a stair step! It's because we round our error_x/y to start_x/y. But our calculated vector_x/y comes from taking the real_x rounded towards start, then deriving the y using that x, and rounding that towards start. The error will always end up off like this. In fact the derived real vector x/y will be off too. That's the whole point of inferring y from x, because those correctly tracked values will trigger stair steps.

This might be a huge break through in logic. Unfortuantely I can't change how I calculate my rounded error because that defeats the point of comparing our derived x/y with a "correctly tracked" x/y. As tempting as it is to try and fix this now, let's sleep and try to fix this with a fresh mind. I think we're very close though.


6th of September, 2023

Simply throwing the plan from last night into the existing code didn't work. But that's because what we need to is return the error x/y or derived line x/y depending on delta_on_angle. What I actually just implemented corrects the line towards error when delta_on_angle is too small. That's not the same thing.

Added some code that changes color of drawn positions if there is an angle change. I was worried we were having jumps in our lines even when deriving from the equation. But I was wrong, I'm just not as steady on the stick as I thought I was.

By snapping the line equation to the error when less than delta on line threshold, and snapping error to line when passed delta threshold, we almost pass all tests. The stair stepping still gives us trouble, however if we check the number of stair steps, it's never more than 2. Which means we have crappy logic when changing angles still, but we correctly draw pixels by the line equation when moving along a true line.

So how on earth do I fix this last piece of the stair stepping puzzle?

I feel confident stating that our movement along lines is perfect. It's our movement where the angle changes frequently that's bad. And I have a strong suspicion it's because of how we round the error position. My current theory is that it should be possible to make an educated guess on how we should round the error based on past positions. For example, imagine drawing a circle. With our current system we're always rounding towards the start_x/y. But if the angle is changing every frame, and our velocity is less than 1, that's the same as just flooring it.

I also just realized that increasing the delta_on_angle threshold also increases the perceived smoothness. And this makes sense to me because the more we increase the threshold, the longer the instance can travel and simply display the floor of its true position. And this feels smoother.

Let's explore some math around tracking multiple vectors, and forming the best guess of a line from those vectors.

Actually after looking at it for a bit. I don't think it's possible. You need to know the future points in order to infer the points of an elegant line.

I was also left wondering if my error rounding is imperfect. But I think the way we do it now, of rounding towards the last recorded start_x/y makes perfect sense. Because we're trying to pull the resulting x/y back towards the start of the vector. That works perfectly when deriving a line. But when just displaying raw points, if we haven't crossed our delta threshold yet. I think that's the best we can do :(

There is another small error. I'm noticing strange jumps backwards when moving with the stick sometimes. I have a suspicion what's happening is the position of error is notably different from the line derived position. But on the frame where delta_on_angle moves passed it's threshold, we don't error correct. But on this frame it's very possible the value derived from the line could be different enough from error that it should have been corrected. If I'm right, fixing that logic shouldn't be too tricky. But I need to create a reproducable case first.

Reproduceable case made. And error observed. I'm pretty sure error correcting the same frame we also switch over to inferring from line equation will fix it. I was worried this would create a bigger offset, but that shouldn't happen because when we error correct, we reset the line. So the derived value will be identical to whatever the rounded error was when we set it.

Ah, our logic wasn't quite right. The position after increasing the delta_on_angle is different once it crosses the threshold. 

I think we may have just got it. It passes all my tests. The visuals look correct. I think it's finally actually doing what I wanted it to do. This is very exciting. It's possible I could just release this as-is, but I can't help but wonder if we can't fix those last few ugly stairsteps that occur when making frequent but very gentle changes to the angle? Like slowly turning an analog stick.

Let's steal from the idea of rollback. If the user is inputting an angle at any moment, it's a very likely guess that the thing they'll be inputting that same angle, or one very similar, the next moment. What if we anticipated the next movement, and position of the current movement and the anticipated movement would create a stairstep, we simply return the previous value for rounded error?

This could work. Although I think we should stop calling it "error" and start calling it "anticipated". We could track "true" x/y, and have get_anticipated_xy to pair with our derived_xy functions.

I think we can define an integer position in our line as a stair step if:
the distance to the previous integer position is 1
the distance to the next integer position is 1
the distance between the previous and next integer positions is exactly sqrt(2)

What I'm currently wondering is if we can simply track the internal state of the positions. Determine if the current location is a stair step. And if it is, simply return the previous position? Let's try tracking the previous position, and adding separate get_x/y functions that return the previous position if the internal state detects that the current position is a stair step.

It's possible this will work. But since we have functions to anticipate moving by a vector, we have to differentiate between the functions we use internally, which don't account for stair stepping and reference the true calculated values, and the user facing functions which do. For example the user facing smooth_move_get_x_if_moved_by_vector should account for x changes (or lack of changes) due to stair stepping. But we also need a get_if_moved_by_vector that doesn't account for stair stepping.

I did some puzzling in my mind, and I've realized this may get rid of stair steps, but will introduce gaps in certain situations. Let's keep trying to add this sytem. It's possible we'll prefer gaps over stair steps depending on the context.

We after implementation, I think it's working. I do still see some stair steps sometimes, but it's rare, and only when changing directions pretty aggressively. It makes sense that sometimes they'd appear, but I want to confirm the reason they're appearing is the reason I think they should appear.

Oh wait I'm stupid, we already have a test for checking gaps, which this currently fails, let's just use that.

We've added a lot of changes. Most of them to do with tidying up and preparing for release. I think there are still bugs in the code, but it's so close to being what I want that I'm ready to release and move on. 


function camera_init_basic(_width, _height, _window_multiplier = 1) {
	view_enabled = true;
	view_visible[0] = true;
	camera_set_view_size(view_camera[0], _width, _height);
	window_set_size(_width * _window_multiplier, _height * _window_multiplier);
	surface_resize(application_surface, _width, _height);
	window_center();
}


7th of September, 2023

I'm still bothered by the existing stair step issues. We were able to create a situation that has both a gap and a stairstep. Let's observe what's happening here. I have a hunch that if the anticipated vector wasn't the same as the previous, but changed the same as the previous changes, we'd have much better looking lines.

Hmm, right now we reset the previous and anticipated x/y whenever the angle changes. Why do we do that? I figure we never want to reset this data unles we didn't move. Actually it specifically doesn't make sense to change that data because we need to refer back to the previous position to determine if the current position is a stair step.

Let's re-hash the logic in our mind. We always move the smooth move instance by our internal line and rounding rules. There is always a "true smooth position" internally. We define a stairstep for smooth move as a position where the distance to its previous "true smooth position" is 1, the distance to its anticipated "true smooth position" is 1, and the distance between it's previous and anticipated "true smooth" positions is exactly sqrt(2). So anytime we reset the previous or anticipated position, we lose the ability to determine if a position is a stair step.

And, actually, now that I think about it why do we even need to reset when the magnitude is 0? Let's pretend we're moving by 0 and our current position is not a stair step. Well... that just means our position gets set to where it is, our anticipated position becomes the same spot, and our previous position is still what it actually was. This won't trigger any false stair steps on the next move because the distance from current to anticipated will be 0 (they're the same!).

I briefly wondered if we could replace our anticipated x/y with just a magnitude value, and we instead derive the anticipated value. But this requires more calculations, and is actually more code in the end. We'll just set anticipated after movement. Now that I've puzzled this out, I feel fairly confident. All we're going to change is never resetting the previous or anticipated positions. Let's commit and try it.

Oh I think I see our trouble with the logic. To set anticipated we copy the smooth move instance, and move it along the same vector. But of course moving the copy triggers the copy to calculate its own anticipated, which makes a copy that calculates its own anticipated, which makes a copy that calculates its own anticipated, which...

And I tried to solve this by making different functions which do or don't calculate the anticipated, and calling the correct one. I'm very tempted to redo the movement code so that we don't have to copy the vector for our internal functions. The only function that makes sense to allow for a copy are the user facing get_if_moved functions. I'm convinced. We should redo our internal move and get_if functions so they don't have to make copies. My plan is to first redo "get_x/y_if_moved_by_vector" so that I can call it without triggering loops. Then the move function itself could be changed to just:

previous_x/y = get_x/y();
start_x
start_y
angle
delta
delta_on_angle
true_x
true_y

err wait... this is getting complicated quickly. No wonder I just decided to copy and update the copy. This makes sense actually because our position is derived from an internal state using mutliple variables. So we can't "derive" the next position easily. So perhaps is makes sense to have an internal "move" which doesn't set or change previous locations, but just the current state data.

What might actually make more sense down the line is to have a separate class that's called something like "smooth_position". And all this thing can do is move. But then our smooth move class would maintain one of these for its current position, remember the previous one for its previous position, and have one that's been advanced by the same vector for its anticipated position. Then our smooth move class and functions could use stair step fixing to decide which of these to display when calling "get_x/y".

But for now. That's basically already what we're doing, except we're just storing the previous position manually, and using a smooth move as the future state, but ignoring all the user facing functions. It's like a class that is both the thing that needs to be used, and the thing that uses it.

Ha, looking over the code I bet the line data could be its own class. It's just sthe start positions, angle and delta. It could have its own get_x/y functions.

Just finished making those changes. Tests still pass, and the lines appear to be much better now. Though it's still not perfect. I truly feel like if we're only ever moving by magnitude of 1 it should be possible to always show a pixel. I believe we should be able to get this to pass our pixel gap skip test.

I believe the path to better anticipation is more accurately guessing the next vector. For example, if moved by these angles and magnitudes:

angle: 0.01, magnitude: 1
angle: 0.02, magnitude: 1
angle: 0.03, magnitude: 1
angle: 0.04, magnitude: 1

I think it's a pretty safe bet the next vector will be:

angle: 0.05, magnitude: 1

But our current system doesn't do that, it will use an angle of 0.04. Here we can see the change between angles is identical. No magnitude change and an angle change of 0.01. I bet we can calculate the average change over the last few vectors and use that average change to anticipate our next vector. I'm pretty sure there's also math that lets use decide how accurate the average is, and we could disregard the anticipation if the average is too unlikely. We'll just google stuff about statistics I'm sure we'll find it.

However, before we do all that. I think it's best if we consolidate our code better by moving logic into those classes I discussed before. The Line and Position object. This will allow our previous and anticipated logic to be more clear.

We mostly transferred everything successfully. But there's a bug in one of our demos. There's some super aggressive stair stepping happening. However all our tests pass. I believe I have identified the source of the problem. When setting the previous location, we use the raw location. But I'm pretty sure the actual previous location should account for stair steps. Regardless though... I'm frustrated our tests didn't catch this. Let's focus on making a test that fails in the current state first. Then fix the bug.

Our tests has the wrong logic, because when moving towards a point there will likely be multiple y positions for 1 x position. Obviously if it's a vertical line that's going to happen. I'm not exactly sure how to write a test for when stairsteps appear but shouldn't. Regardless. I think we fixed the bug. We were setting the previous position to the actual position. But we need to set it to the inferred position based on stair step rules.

It looks like there is still some stair steps happening when I wouldn't expect. I think I'm finally ready to try improving the anticipation system. I'm worried it won't fix all the random stairsteps and gaps I see, but hopefully it'll at least be better. As a reminder, we're going to accumulate vector changes, and average them to guess what the next vector change will be. We'll track an array of vectors. On 0 movement we'll clear it. When the angle changes (with vel > 0) we'll add that vector to the array. We'll cap it at maybe a size of 4? I dunno we'll play around with that number. Once it reaches cap then oldest vectors will be replaced with new ones. Finally the anticipation vector will be dervied by averaging the differences between all vectors in the array.

Just averaging the last few vectors together doesn't work. The average will always be draw pull the vector back to where it was, not where it's probably going. We need to look up best fit line euqations.

We added something using best line forumla. It's very simple. Just derive a line equation from first and last known points. Then infer new point (angle or magnitude) using that line.

After toying around more I realized I can actually trigger gaps even when only moving in the cardinals and their intermediates. This is very frustrating because my tests didn't catch this. I'm ripping out this complicated anticipation system in favor of the old "just use the previous vector to anticipate" strategy.

Something else I've noticed is that it's pretty easy to trigger stair steps when moving by the controller at a very slow rate. I have a theory as to why this is happening. When the movement is super slow, your previous position ends up being your current position for multiple frames. This breaks our previous position stair step logic. Let's see if we can ensure that previous position is only changed when you actually move.

That seems to have helped, but not much. I have a new theory. What if we changed our delta line threshold to simply be number of updates? Movement is much cleaner when deriving from a line. When moving very slowly however, it takes much longer to hit that delta_on_angle threshold. Perhaps it should be number of movements rather than a distance. 

Using number of movements instead of delta seems to work much better.

For fun I tried turning the threshold up super high, like 4000, and I noticed something very interesting:

The movement still looked really good! Diagonal and straight movement was still perfect. I'm guessing this is due to rounding towards the start_x/y. But the curved random lines from my controller still looked great as well. Perhaps the simple stair step correction accounts for more than I was giving it credit for.

In any case. I feel like this thing is about as good as I can make it given my current skill level. I don't have any more ideas to improve it. Let's just tidy up the code base as best we can so it's easily useable, then focus on releasing it.

Think I'm going to leave show_stairsteps as false by default, but I'm very torn on this.

The next steps are to finish the collision demo, just so we have an example of that, and then to capture gifs of exact problems that this fixes. After that we'll plan out the release content.

We encountered an interesting bug while working on collision code. We're colliding against a wall at slow speeds. Magnitudes are:

x: -0.3
7: 0.6

We're mmostly heading south here, and running into a flat wall. Let's just assume our position when we hit the wall is 0,0. Well if you apply this vector, the internal true position of SmoothMove is -0.3, 0.6. That's fine becuase that gets rounded back to 0, 0 and no collision with wall. But when you apply that again you'll be at -0.6, 1.2 which is 0, 1. That yields a collision with the wall and so our collision code corrects us to move at a vector of -0.3, 0 instead. Except this is an angle change of 90 degrees, which triggers our true position reset back to 0, 0. On the next frame we'll attempt to move -0.3, 0.6 which yields a true position of -0.3, 0.6 and now we've looped. In order for this collision system to work the internal true position can't reset when the angle changes. The angle has to change in order to correctly account for sliding movement.

So this brings me back to trying to remember why we reset the true position on angle changes. Let's try undoing that, seeing what breaks, then explaining it here.

So... I completely removed resetting on angle change, and it seems to work almost perfectly fine. I have noticed a few times there were pixel skips when only moving by cardinals and intermediates. But it's very difficult to reproduce. But if I set show_stairsteps to true, there seems to be no problems with cardinals/intermediates. And control stick movement appears to behave the same.

Something is not right under the hood. Unfortunately I don't think we were as close as I thought. Something that is clear, however, is we simply can't reset true position on any angle change if we're going to have collisions work (which is critical). Only on movement of 0 can we reset true position. Therefore I think I can confidently say we should commit to this delete true reset on angle change code. 

It bothers me that we keep missing that pixel gaps are happening. We should make a test that moves around by cardinals and intermediates only and checks for pixel gaps. In theory this should never happen. But our current state allows them when show_stairsteps is false. Let's make a test that fails with current state before moving forward.


We had a crash!?!? This was just moving the object around. This line is related to the code for drawing trails, which is just a debug tool. So hopefully we can ignore it since, whatever bug is there, isn't in SmoothMove itself.
___________________________________________
############################################################################################
ERROR in
action number 1
of Draw Event
for object obj_test_smooth_move:

trying to index a variable which is not an array
 at gml_Script_anon_gml_Object_obj_test_smooth_move_Draw_0_2491_gml_Object_obj_test_smooth_move_Draw_0 (line 91) -        draw_set_color(_v[2]);
############################################################################################
gml_Script_anon_gml_Object_obj_test_smooth_move_Draw_0_2491_gml_Object_obj_test_smooth_move_Draw_0 (line 91)
gml_Object_obj_test_smooth_move_Draw_0 (line 90)


Oh gosh... we already had diagonal only testing... we're really losing track of ourselves.

Also something that's starting to bother me is our stairstep system might be good enough to just forgo the entire line system. It seems to achieve the exact same result. Lets fix the existing bugs then test more to be sure.

We were able to trigger a pixel skip moving just by cardinals. We did this by increasing the number of moves needed before inferring from line. It's clear now that our stair step fix is what triggers the gap.

99.8908729652602
-22.837049096097928

99.8908729652602
-23.837049096097928

99.18376618407365
-24.544155877284474

98.4766594028871
-25.25126265847102

97.76955262170054
-25.958369439657567

This sequence of x/y positions, although only ever moving by a magnitude of 1, will trigger a stair step. The gap occurs when the current position is considered a stairstep, but the angle changes and brings the next position to a pixel that is not adjacent to the current (or technically previous since it's a stairstep) position. 

I'm not actually sure I want to fix this because the behavior is very true and consistent. But at the same time it totally doesn't work when only moving by cardinals or intermediates.

Hold up... how do we even end up with an x of 97.76955262170054? Always moving by 45 degree increments at a magnitude of 1 should only ever leave our x/y position at an integer, or an integer +0.5. Let's track our movement and see what happens. Oh noooo I'm completely wrong. My math here was ignorant. Moving by 1 at a 45 degree angle means the x/y components are always 1/sqrt(2). This will never be an integer.

So if we want cardinal/intermediate changes to always be perfect, perhaps it's a better sacrifice to reset the true position on angle change. So that we are always moving by mathematically perfect lines. This does mean we'll lose some distance when changing angles, which feels a bit slower? But perhaps that's better. However this doesn't fix our original issue of resetting true on angle changes ruins our plans for collisions.

Oh, actually, we should confirm if removing the angle change resets true fixed collisions first.

Collisions did not get fixed. Not only that, but it seems like our position tracking system has been incorrect this entire time. 

Wait! I was wrong about position tracking. I'm pretty sure we're doing it correctly. But what's actually happening is there's a gamemaker bug or something where the game doesn't render the same frame a "Resizing swap chain..." event happens.

Well GameMaker is being an absolute garbage pile right now. It's crashing on me whenever I try to debug certain things, so I'm having a really hard time reaching the critical lines of code that show me what's wrong.

I have a theory about why collision is failing. When we change angles we reset the line equation and start positions, and force the state to read from true positions instead. It looks like our rules allow the true state to get further than the line equation does. So we're able to get right up to the wall with a true position that's further than the wall. And once we try to move differently to "slide" our SmoothMove interprets our position from the perspective the now too far true position.

Ok I think I've discovered the issue, and it's because of stair steps. While moving against the wall it's possible for the next position to be considered a stair step. If this happens the internal state of the smooth move is still advanced along the vector because the returned value of "get_x/y_if_moved_by" will be it's previous position. But since the internal state has moved forward, although our returned position might something like (0, 0), if we move by 0 then SmoothMove sets its position to that of its internal state, which is the stairstep position of (1, 0), or (0, 1) or whatever.

To solve this, I think what we can do is track two position object states, one for current and one for previous. And when we move by 0, if current is a stair step, we'll set current to the previous position. I'm a bit concerned about using an entire state to track just an x/y value, but it should be fine. We have to remember that when moving we can only set the previous position to the current if they're not the same.


Welp that fixed the entering the wall issue, but the collision still doesn't slide. And that's because since we hide stairsteps, we're constantly reverting back to the old state whenever we move enough fractions of an integer make the next position considered a stair step. Simply turning off stairsteps fixed this bug.

So I'm at a real crossroads now. I can't think of an elegant way to allow collisions to still work with my current stair step system. Here's something else. I've been noticing the performance of this project getting worse and worse. And I'm confident it's because the stair step logic involves copying structs and recalculating data from them multiple times every frame.

Stair stepping breaks collisions, it's slowing down the game, and I'm having a really hard time making them perfect. I think the right path forward is to just remove this feature completely. And revisit it some other time. Besides, removing stair steps only seems to really help those gentle arcs you can make frequent subtle changes, like a controller. And I think if you're making the kind of super low res game this library benefits, an input with such fine gradiant is probably not even on your radar.

Ha, without stair steps we don't need anticipation or previous. And without anticipation or previous, there's not need for the separation between a position and the SmoothMove class. I guess splitting out the classes was a waste.

Well now that we don't remove stairsteps, we are getting stairsteps at 45 degree angles.

I can't think of how to fix this and I'm having a really hard time puzzling this out. Stairsteps at 45 degree angles are like the main thing we're trying to avoid. In fact that was the entire reason I started this project. I had a brief thought. What if we reverted back to before removing ripping out stairstep anticipation. But we changed our collision logic so that we don't move by an axis if there is a collision 1 away, instead of by the component of the axis? This is slightly annoying because it means any collsion logic we make using this library will only work for this library, but perhaps it's worth it? 


I"m starting to reconsider if I'm designing this library in the right way. The whole goal here was to make something that made it very easy to move along straight lines. I think I've gotten so obsessed with making it able to accomodate any conceivable movement, I've lost sight of the goal. Let me say a new concept. What if we redid the move functions so there was an optional "lock to integer" variable. When true, the new movement would immediately start deriving position from the line equation. But if false, we'd let the system do its usual thing of using true position rounded to starting position. We basically already allow the user to do this, but only be setting the movements_on_angle threshold. I think that instead of that being something that's set for the entire SmoothMove instance, we could set it by movement. Or more accurately, set if a movement immediately overrides that threshold.

And the default setting for the move should be to cross the threshold immediately and start deriving from lines. Why do this? Because this library is about doing pixel perfect movement for low res games. I think the vast majority of these games are going to have simplistic movement styles, like 8 directions only, and probably binary inputs. In 99% of cases using this library we'd want to use the line right away. Perhaps what we should actually do is make two separate move functions, one that starts deriving from line immediately, and the other lets it derive from true position until SmoothMove automatically crosses the threshold.

I have another grand claim. We should rename this to PixelMove, because it's not about moving smoothly, it's about moving by pixel perfection. And for the move function that waits for a bit before enforcing the line, we could tack "smooth" onto the end of it:

pixel_move_by_vector();
pixel_move_by_magnitudes();
pixel_move_by_vector_smooth();
pixel_move_by_magnitudes_smooth();

Before we commit hard to this though, let's make sure we can still do collisions when movement is forced to lines.

I also had one more thought, we could keep our system of switching from drived true_x/y to line with another function called hybrid. 

We were able to create functioning collisions using just derivation from line functions. I'm confident that our above description is the correct path forward. Maybe this will be the final major change up?

First let's remove the anticipation and previous system again.

Oof, our collision code wasn't quite right. It's tricky when we're at an exact angle because moving by 0.49 on both axis creates a situation where we have to check by +1 pixel along the axis, but only increment by 0.49 on that axis. Which results in a situation where the logic thinks there's no collision moving by 0.49 on x then 9, but in fact there very much is. We'll have to rewrite it so we either move both, either, or none.

We're close but not there. I can tell I'm burnt out and not thinking well. Sleep and try again later. I know this is solvable. 


9th of September, 2023

Still messing with line based collisions. I still struggle to remember that using the line system doesn't let you just move by different magnitudes on the x/y axis. Now, although I'm sure it's possible to work this our using magnitudes, let's try a different approach. Let's try moving by vectors. For moving along an angled line, it should be simple, we'll just increase the delta until we either reach the goal delta, or there's a collision. Since increasing the delta by 1 would never create more than a 1 pixel change, that should be fine. The tricker part comes with determing the correct angle to move along if there is a collision at x/y movement.

When we first start detecting collisions, we'll first detect if the collision allows for movement along just x axis, just y axis, or both. If it's both we can use the original angle, and just increase delta until collision or max delta reached. And although that same logic is true for x/y, we have to figure out what angle to use based on the original angle. Actually, it's not too hard. For x angle of 0, we use that if the original angle is between pi/2 or 3pi/2, we use x angle of pi if it's not 0. And for y we use angle pi/2 if the original angle is between 0 and pi, 3pi/2 if it's not. We can stress the inclusive/exclusives later. This all makes sense actually. Let's try it.

We got close, but we still have trouble at corners where the angle is slightly off the cardinal directions. It looks like seince we're checking the pixel exactly sqrt(2) away at a diagonal, we end up not checking the pixel we'd actually approach. When moving by the actual vector, we could end up just 1 pixel different along the vertical but 0 along the horizontal, or the other way around. So I think this means that in order for diagonal movement to be valid, there can't be a place meeting 1 pixel away just horizontal, 1 pixel away just vertical, or 1 pixel away on both axis.

As far as I can tell, that last change fixed it. We finally have collisions using pixel perfect line movements.

Now that we've created functioning collisions. It's time to rip out the entire stair step system again in preparation of creating the functions I described above.


Now let's rename everything to "pixel". PixelMove.