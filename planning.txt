31st of August, 2023

We're redoing the old bresenham line movement system we did a while ago. But this time we're doing it cleaner.

Last time I used this overly complicated linear line equation system, but in reality we can just use sine and cosine and a vector to derive our ending x position. Or so I thought. We've run into some sort of bug where, now that I've rigged this up to an analog stick with variable degrees, our movement gets stuck and stops at certain points. Since our logic resets the movement and starting point of the SmoothMove instance whenever the angle or vector changes, my first thought is that the frequent angle changes that occur when using an analog stick trigger frequent resets. So the object feels "stuck" when changing directions. 

However, I also noticed that the moving up and to the left stays very fast. Moving down and to the right is the worst. I think it's very likely there is a floor() somewhere in our code that favors movement to the left and up. Let's look around for that first.

We were able to resolve the inconsistency of the sticking (we were rounding our final result, instead of the adjustments). But now the object just feels like it's consistently sticking. I'm confident that our issue is abandoning any progress along the x/y axis made when changing the angle. My first thought to fix this is, strangely enough, going back to something similar we had in the old system. In that system we kept track of the distance travelled along the x/y axis. And those values only reset once there was no change, or the direction flipped.

I think we should try this. However I'm relaizing this means we'll be constantly inferring the x/y magnitude of the stored vector. At this point I think it makes more sense to have SmoothMove store an x/y magnitude instead of an angle and magnitude. But create functions that use a vector to set the x/y magnitude.

Wait, I might be being an idiot. Can we just keep track of the distance traveled by x/y magnitudes relative to a start X, round those distances traveled towards 0 when calculating the x/y position, and simply reset the distance traveled to 0 and the starting position when the sign of the magnitude changes?

That did not work. I believe that's because anything short of an equation deriving one y per x, or the reverse, allows for more than one y per x. And that's what creates the waggle we're trying so hard to get rid of.


1st of September, 2023

We were able to fix the sticking issue. When the x/y magnitudes changed, we simply set the x/y to the currently calculated positions, but also removed the integer portion of the distance_x/y value. For example, on magnitude change:

start_x: 0;
distance_x: 7.4

would become

start_x: 7;
distance_x: 0.4;


We also reset the distance_x/y to 0 on sign change of magnitudes. We've run into another bug now after some more rigorous testing. We're keeping track of distance travelled for both x and y. However since we infer either x or y from a line equation based off the slope, at any given time one of the sitance values is pointless to track. It's also "wrong" compared to the line equation. 

For example, imagine we started at 0,0 and moved 5 times with the vector (-0.7, 0.3). From simple math we could conclude our end position would be (-3.5, 1.5). And the internal state of our SmoothMove would reflect this:

start_x: 0
start_y: 0
distance_x: -3.5
distance_y: 1.5

Remember that we infer y from x with this slope of 0.3/-0.7. And in this case our exact y turns out to be 1.5, the same as the y infered from distance. Now let's change the vectors we're travelling with to (-0.02, 0.1). When we first change this our SmoothMove state will reset the distance x/y and the start x/y and our internal state will become:

start_x: -3
start_y: 1
distance_x: -0.5
distance_y: 0.5

Now let's travel with this vector 5 times. Our state becomes.

start_x: -3
start_y: 1
distance_x: -0.6
distance_y: 1

Notice that the distance travelled is maintained for both axis. Now in this scenario our rise is greater than our run, so we infer our x from our y, which with this slope of -0.2 yeilds an x of -3.4. You'll notice that this is not quite the same as our above distance_x + start_x of -3.6. Luckily since we round to integers towards 0 for changes, our final x is the same with either. But now let's change the vector to (-0.1, -0.3):

start_x: -3
start_y: 2
distance_x: -0.6
distance_y: 0

And let's travel 4 times:

start_x: -3
start_y: 2
distance_x: -1
distance_y: -1.2

Since our rise travels further than our run, we infer our x from our y. So with a slope of 0.333 we can infer our true x from 0.333 * -1.2 + -3, which gives us -3.3996. This is quite different from the x we could infer from just adding start_x and distance_x, which gives us -4. And most importantly, since our logic rounds changees towards 0 when inferring x/y so we return integers, our change value of 0.333 * 01.2 is -0.3996 which rounds to 0. So the final value is -3. That's definitely not -4.  

So what's the problem? The problem here is that keeping track of the distance x/y separately yields an untrue change in vectors when the slope changes from being y/x to x/y. In the above state we infer x from y by calculating a new "distance_x" from a line equation, and in this case that change is 0.333 * -1.2, which is -0.3996. But our internal distance_x is -1. So if we changed vectors to a flipped slope our internal state would change to:

start_x: -4
start_y: 1
distance_x: 0
distance_y: -0.2

And this is wrong! It should be:

start_x: -3
start_y: 1
distance_x: -0.4 // -0.3996 rounded
distance_y: -0.2

But also note that if we flipped to a slope with a greater run than rise, we'd be inferring our y from our x, and so the true "distance_y" wouldn't be -0.2. It would be whatever change we got from our slope * -0.4, or whatever the x distance would be after travelling.

So, now that we've explained the bug, how can we solve it? I actually think the solution isn't too tricky. We already explained how we can infer the true distance x/y from the current slope. I think that we get ride of distance_x/y in favor of just a single distance variable. And use the slope to infer if this distance is along the x or y axis when determing final x/y values. Whenever the vector changes, if the slope has flipped from greater run to greater rise, or the reverse, we calculate the new distance using the old slope and old distance. As an example, let's reimagine the movements from above but using this new system. 

start: (0,0)
vector (-0.7, 0.3) 5 times
vector (-0.02, 0.1) 5 times
vector (-0.1, -0.3) 4 times

Our new starting state would be (and lets include the vector for clarity this time):

magnitude_x: 0
magnitude_y: 0
start_x: 0
start_y: 0
distance: 0
// inferred true position:		(0, 0)
// changes towards 0 position:	(0, 0)

Now we'll set the vector to (-0.7, 0.3) and travel 5 times. Note that this has a greater x travel distance than y, so we infer y from x. Our state is now:

magnitude_x: -0.7
magnitude_y: 0.3
start_x: 0
start_y: 0
distance: -3.5
// inferred true position:		(-3.5,	1.5)
// changes towards 0 position:	(-3,	1)

Change vector to (-0.02, 0.1). Notice that this has a greater run than rise, so our distance will be changed to the difference between the rounded towards 0 interger y and the true inferred y. But to do this we can simply reset the starting and distance values, then multiply distance by the old slope:

// done with actual values calculation
true_y =			-3.5*(0.3/-0.7)+0 = 1.5
towards_zero_y = round_towards_zero(-3.5*(0.3/-0.7))+0 = 1
new_distance = 1 - 1.5 = -0.5;

// done with new distance and old slope calculated
magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: -0.5

distance * slope = -0.5*(0.3/-0.7) = 0.1


By coincidence this would be the same as our distance before. But regardless we have our new state:

magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: 0.5
// inferred true position:		(-3.1,	1.5)
// changes towards 0 position:	(-3,	1)

Notice that the true x position changed from before. Although not ideal, I prefer this to our less organized system from before. At least this is consistent. Now we travel 5 times:

magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: 1
// inferred true position:		(-3.2,	2)
// changes towards 0 position:	(-3,	2)

Change vector to (-0.1, -0.3)

magnitude_x: -0.1
magnitude_y: -0.3
start_x: -3
start_y: 2
distance: 0
// inferred true position:		(-3,	2)
// changes towards 0 position:	(-3,	2)

Now travel 4 times:

magnitude_x: -0.1
magnitude_y: -0.3
start_x: -3
start_y: 2
distance: -1.2
// inferred true position:		(-3.4,	0.8)
// changes towards 0 position:	(-3,	1)



Ok, I've been trying to implement the changes I described above. But I am running into all kinds of issues with capturing the true distance after changing slope type. I've decided that, although perhaps less mathematically elegant, our old system was much simpler and worked just fine. To reiterate, what we used to do was keep track of the distance travelled for both x and y. However when the user requested the position of x/y we would infer one of them based off the slope of the vector. This meant one of those values was basically useless until the slope changed. And when the slope did change we'd reset the starting and distance x/y. What this ultimately means is that when the slope does change, our new axis value will switch from being inferred to being what it would have been had we not been inferring it. Contrary to what I said above. I think this is fine. We end up throwing out the distance of the x/y we were travelling on when we switch slopes anyway, so we end up with imperfection one way or another. This way is just much easier to code and read.


It's clear I've made some sort of serious error in my logic. I rigged up something that let's me move a square around with the raw analog stick. It has the jutter/waggle issue that SmoothMove is supposed to fix. But other than that the movement is way smoother. To test further I rigged it to move in a circle by telling it to move by vector, but increasing the angle slightly each frame. It does not move in a circle like we'd expect. Instead it moves in a square shape. Something is very wrong.

I believe I have uncovered the secret of why our system doesn't feel smooth, and feels clunky. After carefully watching our circle drawing rig, it's clear that since the x distance resets when the angle changes, the y never actually changes until the slope is so aggressive that it forces a change of y with even the smallest x distance. After about maybe 2 dozen iterations this is the state I'm looking at right now:

start_y: 70			// program started at 70
start_x: 156 		// program started at 150
magnitude_x: 0.19
magnitude_y: -0.063
distance_x: 0.487
distance_y: -1.048

Remember that our distance_y is updated even though it's not what we use to calculate the final y. But notice that it's beyond -1! If we weren't using our inference system the y would've changed by now. But the y we infer is the slope times distance_x, which turns out to be -0.16. Not enough to trigger a change. And what's worse, when the angle changes again we go through our reset logic which removes the integer portion of distance_y. This is why the movement has still felt stuck and favoring right angles.

We need to think through how we're going to fix this. I'm confident that we need to adjust the start_y by distance_y when the abs(distance_y) is greater than 1. I tried simply adding the integer value of distance_y to start_y when an angle changes. But this does not work because if the vector stayed the same long enough, then the start_y and distance y were updated correctly.

Perhaps we should try only changing the start_y by the integer of the distance_y if the inferred y on vector change is the same as start_y. This may work because it accounts for situations where the y would've changed had the vector not been changing, but ignores situations where it has changed already. So it's like a "catch" for missed y changes.

(note the above also refers to x changes when we're inferring x from y)

Our small fix certainly helps a lot, but we're not quite there. There are now small skips in the line sometimes. And our circle algorithm doesn't draw a perfect circle, and I'm sure it should. 

We've improved it. But it's clear we don't fully understand what's happening under the hood, or what should be happeneing. From observation and expermientation. We found out that gaps were likely happening when slope type did not change. By only accounting for the missed x/y changes when slope stays the same, we were able to get rid of some gaps. But I still see gaps happen sometimes. And after digging some more, it's clear that sometimes the gaps appear because of our new fix! I'm tempted to try one more thing for today and then give up. Let's see if we can "store" a change. We'll mark that a distance_x/y integer change should have happened using our current logic. But then when we actually update distances, if the distance update accounts for our stored change, we won't make it. 

The fix didn't work. My brain is fried. We'll have to look at this some other time.


3rd of September, 2023

Coming back to this with a fresher head. Still don't really understand what's going on underneath the hood, but I have some thoughts I should get down.

Firstly, something that became clear to me is that using the same distance_x when the the vector changes slightly is wrong. Imagine we have a slope of 1, and we've travelled 0.8 along the x axis. Well if we use basic vector math, travelling 0.8 along the x axis with a slope of 1 is the same as travelling 1.13 along that vector. Now imagine if that was our state:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 1
distance_x: 0.8
distance_y: 0.8

With our current "round distance changes towards 0" logic, this results in a position of (0, 0). But what if we changed the slope from 1 to 0? Suddenly our state would be:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 0
distance_x: 0.8
distance_y: 0.8

This would yield the same position of (0, 0), but that's not correct! It should be:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 0
distance_x: 0.131
distance_y: 

Which would yield a position of (1, 0). I believe we should hold a rule in our logic that changing vectors maintains the distance travelled along the vector. This does break physics but let's go with it for now and see what we come up with first. The only time we'll clear distance travelled is when the magnitude of the new vector is 0.

In fact I'm very tempted to go back to our old system of maintaining the actual magnitude and angle of the vector in our state instead of the x/y magnitudes. Actually I'm not even sure we need to keep track of "magnitude". We could just keep track of distance travelled at that angle since we can reset our start_x/y positions once both have crossed the integer threshold. Our new state could literally be:

start_x
start_y
angle
distance

We could infer slope from the angle, and use the logic we have now for determining if we're inferring y from x or x from y. Let's try this.

Oh wow. We ran into the same problem we ran into before over the weekend. This problem is difficult for me to hold entirely in my mind. When the angle changes frequently, every frame for example, if we don't keep track of the distance we would've covered over the off axis, then the only time we can actually switch to the off axis is when the slop of the ange is so aggressive which switch from inferring y from x to the other way around. This is why we kept track of distance for both x and y. 

Let's start calling distance delta.

What I'm wondering now is if there's a way to keep track of the off axis, basically the same way we did with distance_x/y, but this time ensure we're not losing data when the angle changes.

Let's first try making a value to track changes to the off axis as they happen. I have a theory that we could write cod that, once a large enough change in the off axis is detected, we make that change to the off axis regardless of the line equation, and setback the on axis enough to account for this change.

A logic point that I'm having trouble understanding is if this change along the off axis could ever be greater than 1 (or -1). Perhaps after adding to delta we need to see if a change has happened and remove it from our off axis tracking if it has? These are the kinds of uncertainties that make me hesitant to code further. Diving into the problem without a strong understanding of what's going on is just going to breed bugs.

Oh wait. I just had the dumbest idea in the world. What if we allowed SmoothMove to keep track of non-integer start_x/y positions? And we simply calculate the resultant x/y from our vector as we've been doing? We'd only reset the start_x/y to their integer values when tried to advance with a magnitude of 0. Let's see where this gets us first.

This new strat may have been the correct choice all along. However there are still some weird bugs. It's 5:00am and I should've gone to bed so many hours ago. Tomorrow (later today) we'll solve this.


September 4th, 2023

Ok I slept like crap, but our brain is at least slightly fresher. We uncovered the issue from last night. We weren't capping our angle between 0 and 2pi, so our angle was actually greater than 2pi at certain points. Since our logic doesn't account for that, we were using the wrong slope calculation and dividing by 0.

This new system is looking promising, but there's still a few things to work out. Next we need to be sure that it will never create stair steps. Next let's try and force stair steps, and then uncover what's causing them.

So basically we weren't actually inferring x or y from the other, and only using integer values. We were just display a real rounded somehow, which is no different from just tracking the x/y and displaying it rounded. We have another bug, this time when travelling at certain diagonals the final x/y position after travelling with a magnitude of 0 changes from what it should be. It looks like this is because we change the start_x/y on angle change (which also happens when we set vel to 0). But since we need the old start_x/y to generate the correct integer x/y position, we can't. The data has changed once we change start_x/y to the new one. Instead let's try only updating the start_x/y when changing delta with a different angle. We'll have to track the previous angle for this to work.

Nope. Our fix did not work. I'm still confused and I'm ready to give up on this project.