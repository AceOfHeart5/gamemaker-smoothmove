31st of August, 2023

We're redoing the old bresenham line movement system we did a while ago. But this time we're doing it cleaner.

Last time I used this overly complicated linear line equation system, but in reality we can just use sine and cosine and a vector to derive our ending x position. Or so I thought. We've run into some sort of bug where, now that I've rigged this up to an analog stick with variable degrees, our movement gets stuck and stops at certain points. Since our logic resets the movement and starting point of the SmoothMove instance whenever the angle or vector changes, my first thought is that the frequent angle changes that occur when using an analog stick trigger frequent resets. So the object feels "stuck" when changing directions. 

However, I also noticed that the moving up and to the left stays very fast. Moving down and to the right is the worst. I think it's very likely there is a floor() somewhere in our code that favors movement to the left and up. Let's look around for that first.

We were able to resolve the inconsistency of the sticking (we were rounding our final result, instead of the adjustments). But now the object just feels like it's consistently sticking. I'm confident that our issue is abandoning any progress along the x/y axis made when changing the angle. My first thought to fix this is, strangely enough, going back to something similar we had in the old system. In that system we kept track of the distance travelled along the x/y axis. And those values only reset once there was no change, or the direction flipped.

I think we should try this. However I'm relaizing this means we'll be constantly inferring the x/y magnitude of the stored vector. At this point I think it makes more sense to have SmoothMove store an x/y magnitude instead of an angle and magnitude. But create functions that use a vector to set the x/y magnitude.

Wait, I might be being an idiot. Can we just keep track of the distance traveled by x/y magnitudes relative to a start X, round those distances traveled towards 0 when calculating the x/y position, and simply reset the distance traveled to 0 and the starting position when the sign of the magnitude changes?

That did not work. I believe that's because anything short of an equation deriving one y per x, or the reverse, allows for more than one y per x. And that's what creates the waggle we're trying so hard to get rid of.


1st of September, 2023

We were able to fix the sticking issue. When the x/y magnitudes changed, we simply set the x/y to the currently calculated positions, but also removed the integer portion of the distance_x/y value. For example, on magnitude change:

start_x: 0;
distance_x: 7.4

would become

start_x: 7;
distance_x: 0.4;


We also reset the distance_x/y to 0 on sign change of magnitudes. We've run into another bug now after some more rigorous testing. We're keeping track of distance travelled for both x and y. However since we infer either x or y from a line equation based off the slope, at any given time one of the sitance values is pointless to track. It's also "wrong" compared to the line equation. 

For example, imagine we started at 0,0 and moved 5 times with the vector (-0.7, 0.3). From simple math we could conclude our end position would be (-3.5, 1.5). And the internal state of our SmoothMove would reflect this:

start_x: 0
start_y: 0
distance_x: -3.5
distance_y: 1.5

Remember that we infer y from x with this slope of 0.3/-0.7. And in this case our exact y turns out to be 1.5, the same as the y infered from distance. Now let's change the vectors we're travelling with to (-0.02, 0.1). When we first change this our SmoothMove state will reset the distance x/y and the start x/y and our internal state will become:

start_x: -3
start_y: 1
distance_x: -0.5
distance_y: 0.5

Now let's travel with this vector 5 times. Our state becomes.

start_x: -3
start_y: 1
distance_x: -0.6
distance_y: 1

Notice that the distance travelled is maintained for both axis. Now in this scenario our rise is greater than our run, so we infer our x from our y, which with this slope of -0.2 yeilds an x of -3.4. You'll notice that this is not quite the same as our above distance_x + start_x of -3.6. Luckily since we round to integers towards 0 for changes, our final x is the same with either. But now let's change the vector to (-0.1, -0.3):

start_x: -3
start_y: 2
distance_x: -0.6
distance_y: 0

And let's travel 4 times:

start_x: -3
start_y: 2
distance_x: -1
distance_y: -1.2

Since our rise travels further than our run, we infer our x from our y. So with a slope of 0.333 we can infer our true x from 0.333 * -1.2 + -3, which gives us -3.3996. This is quite different from the x we could infer from just adding start_x and distance_x, which gives us -4. And most importantly, since our logic rounds changees towards 0 when inferring x/y so we return integers, our change value of 0.333 * 01.2 is -0.3996 which rounds to 0. So the final value is -3. That's definitely not -4.  

So what's the problem? The problem here is that keeping track of the distance x/y separately yields an untrue change in vectors when the slope changes from being y/x to x/y. In the above state we infer x from y by calculating a new "distance_x" from a line equation, and in this case that change is 0.333 * -1.2, which is -0.3996. But our internal distance_x is -1. So if we changed vectors to a flipped slope our internal state would change to:

start_x: -4
start_y: 1
distance_x: 0
distance_y: -0.2

And this is wrong! It should be:

start_x: -3
start_y: 1
distance_x: -0.4 // -0.3996 rounded
distance_y: -0.2

But also note that if we flipped to a slope with a greater run than rise, we'd be inferring our y from our x, and so the true "distance_y" wouldn't be -0.2. It would be whatever change we got from our slope * -0.4, or whatever the x distance would be after travelling.

So, now that we've explained the bug, how can we solve it? I actually think the solution isn't too tricky. We already explained how we can infer the true distance x/y from the current slope. I think that we get ride of distance_x/y in favor of just a single distance variable. And use the slope to infer if this distance is along the x or y axis when determing final x/y values. Whenever the vector changes, if the slope has flipped from greater run to greater rise, or the reverse, we calculate the new distance using the old slope and old distance. As an example, let's reimagine the movements from above but using this new system. 

start: (0,0)
vector (-0.7, 0.3) 5 times
vector (-0.02, 0.1) 5 times
vector (-0.1, -0.3) 4 times

Our new starting state would be (and lets include the vector for clarity this time):

magnitude_x: 0
magnitude_y: 0
start_x: 0
start_y: 0
distance: 0
// inferred true position:		(0, 0)
// changes towards 0 position:	(0, 0)

Now we'll set the vector to (-0.7, 0.3) and travel 5 times. Note that this has a greater x travel distance than y, so we infer y from x. Our state is now:

magnitude_x: -0.7
magnitude_y: 0.3
start_x: 0
start_y: 0
distance: -3.5
// inferred true position:		(-3.5,	1.5)
// changes towards 0 position:	(-3,	1)

Change vector to (-0.02, 0.1). Notice that this has a greater run than rise, so our distance will be changed to the difference between the rounded towards 0 interger y and the true inferred y. But to do this we can simply reset the starting and distance values, then multiply distance by the old slope:

// done with actual values calculation
true_y =			-3.5*(0.3/-0.7)+0 = 1.5
towards_zero_y = round_towards_zero(-3.5*(0.3/-0.7))+0 = 1
new_distance = 1 - 1.5 = -0.5;

// done with new distance and old slope calculated
magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: -0.5

distance * slope = -0.5*(0.3/-0.7) = 0.1


By coincidence this would be the same as our distance before. But regardless we have our new state:

magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: 0.5
// inferred true position:		(-3.1,	1.5)
// changes towards 0 position:	(-3,	1)

Notice that the true x position changed from before. Although not ideal, I prefer this to our less organized system from before. At least this is consistent. Now we travel 5 times:

magnitude_x: -0.02
magnitude_y: 0.1
start_x: -3
start_y: 1
distance: 1
// inferred true position:		(-3.2,	2)
// changes towards 0 position:	(-3,	2)

Change vector to (-0.1, -0.3)

magnitude_x: -0.1
magnitude_y: -0.3
start_x: -3
start_y: 2
distance: 0
// inferred true position:		(-3,	2)
// changes towards 0 position:	(-3,	2)

Now travel 4 times:

magnitude_x: -0.1
magnitude_y: -0.3
start_x: -3
start_y: 2
distance: -1.2
// inferred true position:		(-3.4,	0.8)
// changes towards 0 position:	(-3,	1)



Ok, I've been trying to implement the changes I described above. But I am running into all kinds of issues with capturing the true distance after changing slope type. I've decided that, although perhaps less mathematically elegant, our old system was much simpler and worked just fine. To reiterate, what we used to do was keep track of the distance travelled for both x and y. However when the user requested the position of x/y we would infer one of them based off the slope of the vector. This meant one of those values was basically useless until the slope changed. And when the slope did change we'd reset the starting and distance x/y. What this ultimately means is that when the slope does change, our new axis value will switch from being inferred to being what it would have been had we not been inferring it. Contrary to what I said above. I think this is fine. We end up throwing out the distance of the x/y we were travelling on when we switch slopes anyway, so we end up with imperfection one way or another. This way is just much easier to code and read.


It's clear I've made some sort of serious error in my logic. I rigged up something that let's me move a square around with the raw analog stick. It has the jutter/waggle issue that SmoothMove is supposed to fix. But other than that the movement is way smoother. To test further I rigged it to move in a circle by telling it to move by vector, but increasing the angle slightly each frame. It does not move in a circle like we'd expect. Instead it moves in a square shape. Something is very wrong.

I believe I have uncovered the secret of why our system doesn't feel smooth, and feels clunky. After carefully watching our circle drawing rig, it's clear that since the x distance resets when the angle changes, the y never actually changes until the slope is so aggressive that it forces a change of y with even the smallest x distance. After about maybe 2 dozen iterations this is the state I'm looking at right now:

start_y: 70			// program started at 70
start_x: 156 		// program started at 150
magnitude_x: 0.19
magnitude_y: -0.063
distance_x: 0.487
distance_y: -1.048

Remember that our distance_y is updated even though it's not what we use to calculate the final y. But notice that it's beyond -1! If we weren't using our inference system the y would've changed by now. But the y we infer is the slope times distance_x, which turns out to be -0.16. Not enough to trigger a change. And what's worse, when the angle changes again we go through our reset logic which removes the integer portion of distance_y. This is why the movement has still felt stuck and favoring right angles.

We need to think through how we're going to fix this. I'm confident that we need to adjust the start_y by distance_y when the abs(distance_y) is greater than 1. I tried simply adding the integer value of distance_y to start_y when an angle changes. But this does not work because if the vector stayed the same long enough, then the start_y and distance y were updated correctly.

Perhaps we should try only changing the start_y by the integer of the distance_y if the inferred y on vector change is the same as start_y. This may work because it accounts for situations where the y would've changed had the vector not been changing, but ignores situations where it has changed already. So it's like a "catch" for missed y changes.

(note the above also refers to x changes when we're inferring x from y)

Our small fix certainly helps a lot, but we're not quite there. There are now small skips in the line sometimes. And our circle algorithm doesn't draw a perfect circle, and I'm sure it should. 

We've improved it. But it's clear we don't fully understand what's happening under the hood, or what should be happeneing. From observation and expermientation. We found out that gaps were likely happening when slope type did not change. By only accounting for the missed x/y changes when slope stays the same, we were able to get rid of some gaps. But I still see gaps happen sometimes. And after digging some more, it's clear that sometimes the gaps appear because of our new fix! I'm tempted to try one more thing for today and then give up. Let's see if we can "store" a change. We'll mark that a distance_x/y integer change should have happened using our current logic. But then when we actually update distances, if the distance update accounts for our stored change, we won't make it. 

The fix didn't work. My brain is fried. We'll have to look at this some other time.


3rd of September, 2023

Coming back to this with a fresher head. Still don't really understand what's going on underneath the hood, but I have some thoughts I should get down.

Firstly, something that became clear to me is that using the same distance_x when the the vector changes slightly is wrong. Imagine we have a slope of 1, and we've travelled 0.8 along the x axis. Well if we use basic vector math, travelling 0.8 along the x axis with a slope of 1 is the same as travelling 1.13 along that vector. Now imagine if that was our state:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 1
distance_x: 0.8
distance_y: 0.8

With our current "round distance changes towards 0" logic, this results in a position of (0, 0). But what if we changed the slope from 1 to 0? Suddenly our state would be:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 0
distance_x: 0.8
distance_y: 0.8

This would yield the same position of (0, 0), but that's not correct! It should be:

start_x: 0
start_y: 0
magnitude_x: 1
magnitude_y: 0
distance_x: 0.131
distance_y: 

Which would yield a position of (1, 0). I believe we should hold a rule in our logic that changing vectors maintains the distance travelled along the vector. This does break physics but let's go with it for now and see what we come up with first. The only time we'll clear distance travelled is when the magnitude of the new vector is 0.

In fact I'm very tempted to go back to our old system of maintaining the actual magnitude and angle of the vector in our state instead of the x/y magnitudes. Actually I'm not even sure we need to keep track of "magnitude". We could just keep track of distance travelled at that angle since we can reset our start_x/y positions once both have crossed the integer threshold. Our new state could literally be:

start_x
start_y
angle
distance

We could infer slope from the angle, and use the logic we have now for determining if we're inferring y from x or x from y. Let's try this.

Oh wow. We ran into the same problem we ran into before over the weekend. This problem is difficult for me to hold entirely in my mind. When the angle changes frequently, every frame for example, if we don't keep track of the distance we would've covered over the off axis, then the only time we can actually switch to the off axis is when the slop of the ange is so aggressive which switch from inferring y from x to the other way around. This is why we kept track of distance for both x and y. 

Let's start calling distance delta.

What I'm wondering now is if there's a way to keep track of the off axis, basically the same way we did with distance_x/y, but this time ensure we're not losing data when the angle changes.

Let's first try making a value to track changes to the off axis as they happen. I have a theory that we could write cod that, once a large enough change in the off axis is detected, we make that change to the off axis regardless of the line equation, and setback the on axis enough to account for this change.

A logic point that I'm having trouble understanding is if this change along the off axis could ever be greater than 1 (or -1). Perhaps after adding to delta we need to see if a change has happened and remove it from our off axis tracking if it has? These are the kinds of uncertainties that make me hesitant to code further. Diving into the problem without a strong understanding of what's going on is just going to breed bugs.

Oh wait. I just had the dumbest idea in the world. What if we allowed SmoothMove to keep track of non-integer start_x/y positions? And we simply calculate the resultant x/y from our vector as we've been doing? We'd only reset the start_x/y to their integer values when tried to advance with a magnitude of 0. Let's see where this gets us first.

This new strat may have been the correct choice all along. However there are still some weird bugs. It's 5:00am and I should've gone to bed so many hours ago. Tomorrow (later today) we'll solve this.


September 4th, 2023

Ok I slept like crap, but our brain is at least slightly fresher. We uncovered the issue from last night. We weren't capping our angle between 0 and 2pi, so our angle was actually greater than 2pi at certain points. Since our logic doesn't account for that, we were using the wrong slope calculation and dividing by 0.

This new system is looking promising, but there's still a few things to work out. Next we need to be sure that it will never create stair steps. Next let's try and force stair steps, and then uncover what's causing them.

So basically we weren't actually inferring x or y from the other, and only using integer values. We were just display a real rounded somehow, which is no different from just tracking the x/y and displaying it rounded. We have another bug, this time when travelling at certain diagonals the final x/y position after travelling with a magnitude of 0 changes from what it should be. It looks like this is because we change the start_x/y on angle change (which also happens when we set vel to 0). But since we need the old start_x/y to generate the correct integer x/y position, we can't. The data has changed once we change start_x/y to the new one. Instead let's try only updating the start_x/y when changing delta with a different angle. We'll have to track the previous angle for this to work.

Nope. Our fix did not work. I'm still confused and I'm ready to give up on this project.

We uncovered that we weren't carefully checking if we were actually using a velocity of 1 at all times. We're going to undo some code, and make sure we're testing more carefully. let's reset everyting to the way it was before we tried using reals for start_x/y.

I have this crazy idea that we could use the same inference logic, but only ever add to the delta and angle when changing angles. It's only once we move by a magnitude of 0 that we reset start_x/y. Quick correction, we'd have to calculate the angle and delta that results from teh previous vector and the new vector.

My theory is that our current line derivation logic when the angle stays the same for a long delta works. But if we instead created a new vector based off changes in angle by summing the new and old, we'd constantly have a correct reference to where the point should be. We'd still round towards start_x/y, which would create an imperfect drawing. But if we reset whenever the magnitude of the new vector is 0, it should be good enough for our simple games. 

I think we've basically reset everything. There is a bug with my arcade stick where the diagonals aren't perfect for some reason but I'm going to ignore this for now since it works with keyboard. So I'm assuming the math is correct but there's some quirk with the stick I don't know about.

Trying to draw the point as a sum of vectors did not work. Well, technically it "works" but it doesn't have the clean pixel perfection that we're looking for. So we're sort of back at square one. I'm tempted to try the off-axis accumulation tactic again.

Turns out our arcade stick issues was the stick itself. It wasn't returning a perfect angle. We fixed it by using some rounding to snap to cardinal directions.

To simplify our job, I think we can safely assume a reset when the angle change is equal to or greater than pi/4. When it comes to accounting for missed changes, I think we can also say that if we experienced a change on the current angle, we don't have to account for missed changes. In my mind I can't conceive how to handle switching from deriving y from x to x from y. If y is the off axis and we're slowly accumulating missed y changes, perhaps from slowly turning a control stick to dead left towards up, I understand that at some point our accumulated y would be greater than 1 (or -1) and we'd have to adjust our values so our line represents this (probably by changing the start_x/y?). But let's say we're moving at slightly less that pi/4. In the same way that moving at an angle slightly greater than 0 will slowly accumulate change towards a positive y change, this slightly less than pi/4 should accumulate towards a negative y change. and further more what happens when the angle changes accross the deriving y from x threshold? I don't understand if that should somehow transfer the accumulated off axis to the new off axis, or just ignored, or some sort of offset with start_x/y should happen right there? 

I have another idea that might be better. Before we tried doing this crazy thing where we added vectors together after each change to try and infer the final drawn point from all vector additions. It didn't work, but what if we tracked something like that between resets? And if the distance between our vector accumulation and our calculated point (which could still use our same logic) was too great, we'd reset to the vector accumulated point. Let's try that and see what happens.

A quick note. This is clearly not good programming. We should instead form a solid plan that we know will work, then implement it. But I'm frustrated and I want to just throw my head against this thing.

The error correction ideas is close. Very close. When using the analog stick it has loads of gaps and mistakes in it, but the movement is otherwise the correct speed and follows the correct lines. That's if we use sqrt(2) as our error correction distance. If we use 1 as our error check, no gaps appears in our lines, but the stick still favors cardinals and intermediates, and "sticks".

Small revelation. We were resetting our error correction when the error was high enough. Except this didn't accomplish anything because we'd lost data on the axis that didn't change. Which was the whole point of this. We changed it so that we only reset the error of the axis that has changed. This looks "better" but it's still wrong. I have a new idea. Perhaps we should always change the calculated values to the error if they're too far off. However we'll only reset the error_correction data if we reset both axis.

Well I'll be. That's the greatest success we've ever had with this. And it makes sense why it works. We're always keeping track of what the "true" value should be. And any time the calculated values are too far off we set them to the error corrected values. So it's always "correct". And we only reset this error correction value if we end up resetting both axis. The problem I see now is that the circle test slowly moves. Is this something that can be resolved? Or is this an inevitable evil with something like this?

We've found a unique situation where our error correction is off from a consistent line. It looks like this is because the magnitudes of the line are less than an integer and our error correction system really only prevents stair stepping for velocities 1 or greater. I tried a couple things to fix this but nothing worked. What I think I'll have to do is only trigger error correction if the equation of the error line is different from the equation line of the SmoothMove. We should also trigger error correction if the angle changed just in case we end up with the same equation by coincidence, but arrived from radically different vectors.

Welp, that's closer still but not quite right. There are still small skips when controlling the pixel with a controller. I've also noticed it favors cardinal directions more heavily than I was expecting.

After fixing an error in our tests. Most of the gaps appear to be gone! It looks like I had made a logic mistake in when we should do error correction. I could've sworn I still saw some gaps, but I'm not sure how to test this precisely. Maybe the next best step is to make a test for this.

We tried making a fix for the gaps by making setting the smooth move position to a pixel in between its calculated position and error position when the error was larger than sqrt(2) (adjacent diagonal pixels). By some miracle this appears to have worked really well. We also made a pretty thorough test for checking gaps. it randomly moves a smooth move instance thousands of times, and checks the distance between each movement to ensure it's never greater that sqrt(2). I am VERY cautiously optimistic right now. It's performing the movement I expected. There are two major things still on my mind:

1. I think I can improve the pixel gap fix further. Instead of just setting it to a pixel in between, we could set it to a pixel, then tastefully adjust the error correction so that it's closer is a way that doesn't cause stair stepping. Some stair steps are probably inevitable, but we may be able to get way closer to 0 than I thought.

2. There's still nothing in here for collision checking. I still have to think through how I'm going to handle that. I know I want the user to pass a callback function to the smooth move that determines if a position is "colliding". The callback would pass in the possible position of the smooth move given a vector movement. It's possible this won't be that hard. We're finally uncovered the logic to determine the "correct" next position. So all we need to do is try positions from where the smooth move is to the correct next position, inching it 1 pixel at a time, until we either reach the correct position or the callback returns true for "colliding". We could also do slides by incrementing just the x or y magnitude, and checking the callback for each individually.

3. It still seems to favor diagonals, and I have no idea why. Worth investigating, understanding, and hopefully fixing.

I was thinking of exploring fixing stair stepping, but I'm not longer convinced it's a problem with error correction. I'm starting to think it's only happening when changing directions to a 90 degree angle quickly enough that stairstepping is actually the most mathematically correct representation. I think I'll stop worry about stair stepping for now, and focus on collision detection instead. I also wonder if the circles appearing to favor diagonals and straights is actually just what circles look like at low res. These are all things I should make sure I understand, but right now the package is working well enough to use. And I think setting up for collisions is the next most important thing.

Just added some code for collision checking. It's not quite right but seems to be close. Today was a big success. Maybe tomorrow we can really finish this thing.


5th of September, 2023

We were able to fix the bug with our collision sliding fairly easily as well as catch a missed infinite loop bug. Next step is to write more and complete tests for collisions.

Wait a second. I just realized we shouldn't put collisions in at all. Collisions are so game specific, our collision system might not work for the user. What we should actually do is add a "position if moved by vector" function. Since most logic for collisions I've seen online work by checking if there would be a collision at a spot, and only moving if there's not, we need to allow for the user to know where a SmoothMove would end up if a vector was applied. Same for moving by magnitudes.

So, a bit dramatic, but let's rip out all this collision code we put in. And instead put in those "potential position" functions.

Ripping out all the collision code turned out to not be difficult at all. And we were able to fairly easily make our own collision code using new "position if moved by vector" functions. After hammering out a few more bugs and adding some tests. I'm genuinely at a loss for what's left in this project besides tidying comments, documentation, and releasing.

After doing some tidying, and more observing, there are definitely still nasty stairsteps in this thing. It might be worth releasing it as is just to have something out there. It does work perfectly fine with just the cardinals and intermediates. Ah, we were able to identify an error with perfect diagonal movement. when moveing at magnitudes 0.5 and 0.5, the smooth move should perfectly alternate between moving and not. Sometimes it doesn't move when it should.

Got some insight into what's causing the stair stepping. Firstly, we're definitely experiencing stair stepping on straight lines. And it looks like it's because our logic doesn't correctly switch our state to our error data if they're close enough. Let's note that in this stairstep case the vector is unchanging, but the error correction constantly things the result of the line equation is wrong. But given what this project is, if we have consistent movement along a line, then that line is correct, not the error. I wonder if we can setup some simple rules during error correction:

If the angle changed, we fit the line equation to the error.
If the angle did not change, we fit the error to the line equation.